"""
Module for reading ICOOPCAR files generated by LOBSTER.
Distributed under the terms of the MIT License
ref: https://github.com/materialsproject/pymatgen/blob/master/pymatgen/io/lobster/outputs.py

Ara Cho @SUNCAT/Stanford
Jul 1, 2023
"""

from monty.io import zopen
import numpy as np
import re
from ase.io import read
from mendeleev import element
from monty.json import MSONable
from scipy.interpolate import InterpolatedUnivariateSpline
import pandas as pd
from itertools import chain

pd.set_option('display.expand_frame_repr', False)
pd.set_option('display.max_columns', None)
pd.set_option('display.max_colwidth', None)
pd.set_option('display.max_rows', None)
np.set_printoptions(precision=5)
orbital_order={'1s':0,'2s':1,'2p':2,'3s':3,'3p':4,'4s':5,'3d':6,'4p':7,'5s':8,'4d':9,'5p':10,'6s':11,'4f':12,
               '5d':13,'6p':14,'7s':15,'5f':16,'6d':17,'7p':18}
metal_elements = ['Li', 'Be', 'Na', 'Mg', 'Al', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi']


class Icoop(MSONable):
    """ ICOOP object """
    def __init__(self, efermi, energies, icoop, data_label=None, icoop_fermi=None):
        self.efermi = efermi
        self.energies = np.array(energies)
        self.icoop = icoop
        self.data_label = data_label
        self.icoop_fermi = icoop_fermi

class Icoopout:
    def __init__(self, filepath='.',):
        self.ICOOPCAR_file=filepath+'/ICOOPCAR.lobster'
        self.POSCAR_file=filepath+'/POSCAR'
        self.atoms = read(self.POSCAR_file)
        self._get_icoop_data()
        self.dict=self._dict()

    def _get_icoop_data(self):
        """
        ref: https://github.com/materialsproject/pymatgen/blob/master/pymatgen/io/lobster/outputs.py
        modified based on the pymatgen source code
        read ICOOPCAR.lobster generated by LOBSTER

        .. attribute: icoop_data
            Dict that contains the ICOOP data of the form:
            {bond: {"ICOOP": {"Spin.up": icoops, "Spin.down": icoops},
                    "length": bond length,
                    "sites": sites corresponding to the bond}
            Also contains an entry for the average, which does not have
            a "length" key.
        .. attribute: efermi
            The Fermi energy in eV.
        .. attribute: energies
            Sequence of energies in eV. Note that LOBSTER shifts the energies
            so that the Fermi energy is at zero.
        .. attribute: is_spin_polarized
            Boolean to indicate if the calculation is spin polarized.
        .. attribute: orb_icoop
            orb_icoop[label] = {bond_data["orb_label"]: {"ICOOP": {Spin.up: icoops, Spin.down: icoops},
                                                        "orbitals": orbitals,
                                                        "length": bond lengths,
                                                        "sites": sites corresponding to the bond}}
        """

        with zopen(self.ICOOPCAR_file, "rt", encoding="utf-8") as f:
            contents = f.read().split("\n")

        parameters = contents[1].split()
        if int(parameters[1]) == 2:
            spins = ["Spin.up", "Spin.down"]
            self.is_spin = True
        else:
            spins = ["Spin.up"]
            self.is_spin = False

        num_bonds = int(parameters[0]) - 1
        self.efermi = float(parameters[-1])
        data = np.array([np.array(row.split(), dtype=float) for row in contents[num_bonds + 3 :]]).transpose()
        self.energies = data[0]
        icoop_data= {
                    "average": {
                        "ICOOP": {spin: data[1 + s * (num_bonds + 1)] for s, spin in enumerate(spins)},
                    }
                }
        
        orb_icoop = {}
        bondnumber = 0

        for bond in range(num_bonds):
            bond_data = self._get_bond_data(line=contents[3 + bond])
            label = str(bondnumber)

            orbs = bond_data["orbitals"]
            icoop = {spin: data[1 + (bond + s * (num_bonds + 1))] for s, spin in enumerate(spins)}

            if orbs is None:
                bondnumber = bondnumber + 1
                label = str(bondnumber)
                icoop_data[label] = {
                    "ICOOP": icoop,
                    "length": bond_data["length"],
                    "sites": bond_data["sites"],
                    "elements": bond_data["elements"],
                }
            elif label in orb_icoop:
                orb_icoop[label].update(
                    {
                        bond_data["orb_label"]: {
                            "ICOOP": icoop,
                            "orbitals": orbs,
                            "length": bond_data["length"],
                            "sites": bond_data["sites"],
                            "elements": bond_data["elements"],
                        }
                    }
                )
            else:
                orb_icoop[label] = {
                    bond_data["orb_label"]: {
                        "ICOOP": icoop,
                        "orbitals": orbs,
                        "length": bond_data["length"],
                        "sites": bond_data["sites"],
                        "elements": bond_data["elements"],
                    }
                }

        self.orb_res_icoop = orb_icoop or None
        self.icoop_data = icoop_data

    def _get_bond_data(self, line: str) -> dict:
        """
        Subroutine to extract bond label, site indices, and length from
        a LOBSTER header line. The site indices are zero-based, so they
        can be easily used with a Structure object.
        Example header line: No.4:Fe1->Fe9(2.4524893531900283)
        Example header line for orbtial-resolved ICOOP:
            No.1:Fe1[3p_x]->Fe2[3d_x^2-y^2](2.456180552772262)
        Args:
            line: line in the ICOOPCAR header describing the bond.
        Returns:
            Dict with the bond label, the bond length, a tuple of the site
            indices, a tuple containing the orbitals (if orbital-resolved),
            and a label for the orbitals (if orbital-resolved).
        """
        line_new = line.rsplit("(", 1)
        length = float(line_new[-1][:-1])

        sites = line_new[0].replace("->", ":").split(":")[1:3]
        site_indices = tuple(int(re.split(r"\D+", site)[1]) - 1 for site in sites) # index start from 0
        elements = (self.atoms[site_indices[0]].symbol, self.atoms[site_indices[1]].symbol) 

        if "[" in sites[0]:
            orbs = [re.findall(r"\[(.*)\]", site)[0] for site in sites]
            orb_label, orbitals = self._get_orb_from_str(orbs)
        else:
            orbitals = orb_label = None

        return {
            "length": length,
            "sites": site_indices,
            "orbitals": orbitals,
            "orb_label": orb_label,
            "elements": elements,
        }
    
    def _get_orb_from_str(self, orbs):
        """
        Args:
            orbs: list of two str, e.g. ["2p_x", "3s"].
        Returns:
            list of tuple of int and str, e.g. [(2, "px", 3), (3, "s", 0)].
        """
        orb_labs = {
            "s": (0, 's'),
            "p_y": (1, 'py'),
            "p_z": (2, 'pz'),
            "p_x": (3, 'px'),
            "d_xy": (4, 'dxy'),
            "d_yz": (5, 'dyz'),
            "d_z^2": (6, 'dz2'),
            "d_xz": (7, 'dxz'),
            "d_x^2-y^2": (8, 'dx2'),
            "f_y(3x^2-y^2)": (9, 'f_3'),
            "f_xyz": (10, 'f_2'),
            "f_yz^2": (11, 'f_1'),
            "f_z^3": (12, 'f0'),
            "f_xz^2": (13, 'f1'),
            "f_z(x^2-y^2)": (14, 'f2'),
            "f_x(x^2-3y^2)": (15, 'f3'),            
        }
        orbitals = [(int(orb[0]), orb_labs[orb[1:]]) for orb in orbs]
        orb_label = f"{orbitals[0][0]}{orbitals[0][1][1]}-{orbitals[1][0]}{orbitals[1][1][1]}"  # type: ignore
        orbitals = [(orbitals[0][0], orbitals[0][1][1], orbitals[0][1][0]), (orbitals[1][0], orbitals[1][1][1], orbitals[1][1][0])]
        return orb_label, orbitals
    
    def _dict(self, summed_spin=True):
        d={}
        for i in range(len(self.icoop_data)-1):
            label=str(i+1)
            d[label]={}
            d[label]['label']=label
            d[label]['distance']=self.icoop_data[label]['length']
            d[label]['ele1']=self.icoop_data[label]['elements'][0]
            d[label]['ele2']=self.icoop_data[label]['elements'][1]
            d[label]['idx1']=self.icoop_data[label]['sites'][0]
            d[label]['idx2']=self.icoop_data[label]['sites'][1]
            d[label]['pair']=(f"{d[label]['ele1']}{d[label]['idx1']}",f"{d[label]['ele2']}{d[label]['idx2']}")
            d[label]['dat_label']=f"{d[label]['pair'][0]}-{d[label]['pair'][1]}"
            d[label]['icoop']=self._get_icoop_fermi(label, summed_icoop=self.icoop_data[label]['ICOOP'], summed_spin=summed_spin)
            d[label]['orb']=self.orb_res_icoop[label]
            
            for j, idx in enumerate(self.icoop_data[label]['sites']):
                orb_temp=[]
                orb_temp.extend(self.orb_res_icoop[label][orb]['orbitals'][j] for orb in self.orb_res_icoop[label])
                orb_temp=list(set(orb_temp))
                d[label][f"{self.icoop_data[label]['elements'][j]}{idx}"]=sorted(orb_temp, key=lambda x : (orbital_order[str(x[0])+str(x[1][0])], x[2]))
                
        return d

    def _get_icoop_fermi(self, label, summed_icoop, summed_spin):
        spl_spinup = InterpolatedUnivariateSpline(self.energies, summed_icoop['Spin.up'], ext=0)
        if not summed_spin and self.is_spin:
            spl_spindown = InterpolatedUnivariateSpline(self.energies, summed_icoop['Spin.down'], ext=0)
            icoop_fermi={'Spin.up': -np.round(spl_spinup(0.0), 5), 'Spin.down': -np.round(spl_spindown(0.0), 5)}
        else:
            icoop_fermi={'Spin.up': -np.round(spl_spinup(0.0), 5)}
        return icoop_fermi

    def print_all(self, sort_by=None):
        """Print all labels and ICOOP values for all orbitals."""
        # change column name of self.dataframe
        df=pd.DataFrame(self.dict).T
        df=df.rename(columns={'icoop':'-ICOOP'})
        new_columns = ['label', 'ele1', 'idx1', 'ele2', 'idx2', 'dat_label', '-ICOOP', 'distance']
        df = df.reindex(columns=new_columns)
        if sort_by is not None:
            df = df.sort_values(by=[sort_by,'label'])
        print(df.to_string(index=False))
        print(f"ICOOP sum: {df['-ICOOP'].sum():.5f}")

    def picoop(self, label=None, orbital=None, summed_spin=True, sort_by=None, index=None, symbol=None):
        picoop={}
        if symbol is not None and index is not None:
            raise ValueError("Only one of index and symbol can be specified.")
            
        if isinstance(index, int):
            labels=[]
            for label in self.dict.keys():
                if index in [ self.dict[label]['idx1'], self.dict[label]['idx2']]:
                    labels.append(label)
        elif isinstance(symbol, str):
            labels=[]
            for label in self.dict.keys():
                if symbol in [ self.dict[label]['ele1'], self.dict[label]['ele2']]:
                    labels.append(label)
        elif label is None:
            labels=list(self.dict.keys())
        elif isinstance(label, str):
            labels=[label]
        elif isinstance(label, list):
            labels=label

        data=[]
        icoop_sum={}
        for label in labels:
            if summed_spin:
                icoop_sum[label]={'Spin.up':[]}
            else:
                icoop_sum[label]={'Spin.up':[],'Spin.down':[]}
            label = str(label)
            picoop[label]={}
            data_label, label_list, orbital_list=self._get_picoop(label,orbital=orbital, summed_spin=summed_spin)
            if not isinstance(label_list[0], list):
                label_list=[label_list]
                orbital_list=[orbital_list]

            for i in range(len(label_list)):
                summed_icoop = self._get_summed_icoop_by_label_and_orbital_list(label_list[i], orbital_list[i], summed_spin=summed_spin)
                icoop_fermi=self._get_icoop_fermi(label, summed_icoop=summed_icoop, summed_spin=summed_spin)
                picoop[label][i]={} # for plotting
                row={}
                row['label']=label
                row['ele1']=self.dict[label]['ele1']
                row['idx1']=self.dict[label]['idx1']
                row['ele2']=self.dict[label]['ele2']
                row['idx2']=self.dict[label]['idx2']
                row['pair']=data_label[i]
                
                picoop[label][i]=Icoop(efermi=self.efermi,
                                     energies=self.energies,
                                     icoop=summed_icoop,
                                     data_label=data_label[i],
                                     icoop_fermi=icoop_fermi)

                if summed_spin or not self.is_spin:
                    row['-ICOOP']=icoop_fermi['Spin.up']
                    icoop_sum[label]['Spin.up'].append(icoop_fermi['Spin.up'])
                else:
                    row['-ICOOP(up)']=icoop_fermi['Spin.up']
                    row['-ICOOP(down)']=icoop_fermi['Spin.down']
                    icoop_sum[label]['Spin.up'].append(icoop_fermi['Spin.up'])
                    icoop_sum[label]['Spin.down'].append(icoop_fermi['Spin.down'])
                row['distance']=self.dict[label]['distance']
                data.append(row)
            
        df=pd.DataFrame(data)
        if sort_by is not None:
            if isinstance(sort_by, list):
                sort_by.append('label')
            df = df.sort_values(by=[sort_by,'label'])
        print(df.to_string(index=False))
        if summed_spin or not self.is_spin:
            print(f"\t\t\t\t-ICOOP sum:{df['-ICOOP'].sum():.5f}")
        else:
            print(f"\t\t\t\t-ICOOP sum:{df['-ICOOP(up)'].sum():.5f}\t{df['-ICOOP(down)'].sum():.5f}")
        return picoop

if __name__ == "__main__":
    pass 